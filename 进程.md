# Linux学习笔记
## 计算机体系结构

三类总线
数据总线 - 传输数据（双向）
地址总线 - 指定内存地址（单向）
控制总线 - 传输控制信号（双向）
进程的结构
###  1. 进程控制块（PCB - Process Control Block）
    这是进程结构中最关键的部分。PCB是操作系统用于描述和管理进程的一个数据结构，每个进程都有一个唯一的PCB。当进程被创建时，PCB被创建；当进程终止时，PCB被回收。可以说，PCB就是进程存在的唯一标识。
    PCB中通常包含以下信息：
    进程标识信息（PID）：唯一的进程ID，用于区分不同进程。
    进程状态：指明进程当前的状态，如就绪、运行、阻塞等。
    程序计数器（PC）：存放下一条要执行的指令的地址。
    CPU寄存器：当进程被切换出CPU时，需要保存所有寄存器的值，以便后续能恢复执行。
    CPU调度信息：进程的优先级、调度队列指针等。
    内存管理信息：基址/限址存器、页表或段表的指针等。这定义了进程的地址空间。
    记账信息：CPU使用时间、时间限制等。
    I/O状态信息：分配给进程的I/O设备列表、打开的文件列表等
###  2. 代码段（Text Segment）
    这部分是只读的，存放进程要执行的程序代码（机器指令）。为了防止意外修改，通常被设置为只读。
###  3. 数据段（Data Segment）
    存放全局变量和静态变量。它在程序开始运行时分配，在程序结束时释放。
    已初始化数据段：存放明确初始值的全局/静态变量（如 int global_var = 100;）。
    未初始化数据段（BSS段）：存放未初始化的全局/静态变量（如 static int uninit_var;），操作系统会在加载时将其初始化为0。
###  4. 堆（Heap）
    用于动态内存分配。当程序使用 malloc()、new 等关键字申请内存时，内存就从堆中分配。堆的内存空间通常向上增长。它的生命周期由程序员控制，如果管理不当会造成内存泄漏。
###  5. 栈Stack）
    用于存放局部变量、函数参数和返回地址。每当一个函数被调用时，一个新的栈帧（Stack Frame）就会被压入栈中，用于存储该函数的局部变量等信息。当函数返回时，其栈帧被弹出。栈的内存空间通常向下增长。它的管理是自动的，由编译器完成。
# 概念
## 进程概念
  程序的执行实例，拥有独立的内存空间和系统资源，包含程序代码、数据、堆栈、寄存器等，是系统资源分配和调度的基本单位。
## 状态
  R (Running)	正在运行或可运行
  S (Sleeping)	可中断的睡眠状态
  D (Uninterruptible)	不可中断的睡眠状态
  T (Stopped)	暂停状态
  Z (Zombie)	僵尸进程
  X (Dead)	死亡状态

## 进程指令
  ### ps
    ps aux                    # 查看所有用户的所有进程
    ps -ef                    # 完整格式显示所有进程
    ps -u username            # 查看指定用户的进程
    ps -p PID                 # 查看指定PID的进程
    ps -C process_name        # 查看指定进程名的进程
   ####   字段说明
      USER: 进程所有者
      PID: 进程ID
      %CPU: CPU使用率
      %MEM: 内存使用率
      VSZ: 虚拟内存大小
      RSS: 物理内存大小
      TTY: 终端设备
      STAT: 进程状态
      START: 启动时间
      TIME: 累计CPU时间
      COMMAND: 命令名称
  ### top
    top                       # 实时显示进程状态
    top -u username           # 监控指定用户的进程
    top -p PID1,PID2          # 监控指定PID的进程
  ## 进程函数
  ### fork()
  #### 核心机制
  写时复制 (Copy-on-Write)：
  
  子进程与父进程共享同一物理内存，
  只有当任一进程尝试修改内存时，才真正复制该内存页，
  极大优化了进程创建的性能。
    
  #### 代码
  
    #include <unistd.h>
    pid_t fork(void);
  ### wait()
  #### 作用
  等待子进程状态改变，主要用于防止僵尸进程
  #### 代码
    #include <sys/wait.h>
    int status;
    pid_t child_pid = wait(&status);  // 传入状态变量地址
    
    WIFEXITED(status)	是否正常退出	返回true/false
    WEXITSTATUS(status)	获取退出码	仅当正常退出时有效
    WIFSIGNALED(status)	是否被信号终止	返回true/false
    WTERMSIG(status)	获取终止信号	仅当信号终止时有效
    WIFSTOPPED(status)	是否被暂停	返回true/false
    WSTOPSIG(status)	获取暂停信号	仅当暂停时有效
  #### 返回值
    > 0：结束的子进程PID
    = 0：选项为WNOHANG且没有子进程结束
    -1：错误（如无子进程）
  ### waitpid()
  #### 代码
    pid_t waitpid(pid_t pid, int *status, int options);
    
    pid参数
    >0指定进程
    =0同进程组任意子进程
    -1任意子进程   同wait
    <-1任意进程组任意子进程
    
    options参数
    WNOHANG      // 非阻塞模式，立即返回
    WUNTRACED    // 也返回停止的子进程状态
    WCONTINUED   // 也返回继续运行的子进程状态
### exec函数族
####    作用
替换当前进程映像，执行新的程序文件，保持相同的 PID，如果成功执行，后边代码不执行
#### 代码
    #include <unistd.h>

    int execl(const char *path, const char *arg, ... /* (char *) NULL */);
    int execlp(const char *file, const char *arg, ... /* (char *) NULL */);
    int execle(const char *path, const char *arg, ... /*, (char *) NULL, char *const envp[] */);
    int execv(const char *path, char *const argv[]);
    int execvp(const char *file, char *const argv[]);
    int execvpe(const char *file, char *const argv[], char *const envp[]);

    l - 参数列表 (list)

    v - 参数数组 (vector)
    
    p - 使用 PATH 环境变量查找文件
    
    e - 自定义环境变量
